var stringifier_1 = require("../expressions/stringifier");
var flow_1 = require("../../flow");
function parseReturnStatement(returnStatement, currentNode, context) {
    var argument = returnStatement.argument ? stringifier_1.stringify(returnStatement.argument) : "undefined";
    var returnLabel = "return " + argument;
    var finalizerCompletion = runFinalizersBeforeReturn(currentNode, context);
    if (!finalizerCompletion.normal) {
        return finalizerCompletion;
    }
    context.currentFlowGraph.successExit
        .appendTo(finalizerCompletion.normal, returnLabel, returnStatement, flow_1.EdgeType.AbruptCompletion);
    return { return: true };
}
exports.parseReturnStatement = parseReturnStatement;
function runFinalizersBeforeReturn(currentNode, context) {
    var enclosingTryStatements = context.enclosingStatements
        .enumerateElements()
        .filter(function (statement) { return statement.type === 0 /* TryStatement */; });
    for (var _i = 0; _i < enclosingTryStatements.length; _i++) {
        var tryStatement = enclosingTryStatements[_i];
        if (tryStatement.parseFinalizer && !tryStatement.isCurrentlyInFinalizer) {
            tryStatement.isCurrentlyInFinalizer = true;
            var finalizer = tryStatement.parseFinalizer();
            tryStatement.isCurrentlyInFinalizer = false;
            finalizer.bodyEntry.appendEpsilonEdgeTo(currentNode);
            if (finalizer.bodyCompletion.normal) {
                currentNode = finalizer.bodyCompletion.normal;
            }
            else {
                return finalizer.bodyCompletion;
            }
        }
    }
    return { normal: currentNode };
}
